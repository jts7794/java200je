package java200je;

public class ArrayTwoInit {

	/*2차원 배열을 선언하여 이용하는 방법은 모두 네가지
	 * 1. 첫 번째와 두 번째 배열의 크기를 모두 넣고 선언, 정의, 자동 초기화하는 방법으로 선언과 정의를 따로 할 수 있다.
	 * 2. 첫 번째 배열의 크기만 넣고 두 번째는 비워놓은 다음 필요에 따라 두 번쨰 배열의 크기를 다르게 할 수 있는 불규칙 배열법 (jigjagged)
	 * 3. 첫 번째와 두 번째 배열의 크기를 넣지 않고 {}를 이용하여 초기화하는 방법
	 * 4. new 키워드를 사용하지 않고 {}를 사용하는 방법  
	 * */
	public static void main(String[] args) {
		//1. 첫 번째와 두 번째 배열의 크기를 모두 넣고 선언, 정의, 자동 초기화하는 방법으로 선언과 정의를 따로 할 수 있다.
		System.out.println("//2차원 배열 방법1");
		int [][] a = new int[4][3]; //4*3배열 
		a[0][0]=1;
		a[0][1]=2;
		a[3][2]=5;
		//...
		println(a);
		System.out.println();
		
		//2. 첫 번째 배열의 크기만 넣고 두 번째는 비워놓은 다음 필요에 따라 두 번쨰 배열의 크기를 다르게 할 수 있는 불규칙 배열법 (jigjagged)
		System.out.println("//2차원 배열 방법 2 (JigJagged도 가능)");
		int[][]b = new int[3][];
		b[0]=new int[4];
		b[1]=new int[5];
		b[2]=new int[6];
		println(b);
		System.out.println();
		
		//3. 첫 번째와 두 번째 배열의 크기를 넣지 않고 {}를 이용하여 초기화하는 방법
		System.out.println("//2차원 배열 방법 3");
		int [][]c = new int[][] {{1,2,3,4,5},{2,3,4,5,6},{6,7,8,9,0}};
		println(c);
		System.out.println();
		
		//4. new 키워드를 사용하지 않고 {}를 사용하는 방법
		System.out.println("//2차원 배열 방법 4");
		int [][]g = {{1,2,3,4,5},{2,3,4,5,6},{6,7,8,9,0}};
		println(g);
		System.out.println();
		
		//https://taesung.tokyo/2020/05/19/2020/05/19/2차원-배열-이해하기/
		//위 주소 참고 (그림 75-1,75-2,75-3)
		
		System.out.println("copy 1");
		int [][]d = new int[c.length][c[0].length];	//3*5배열
		//2차원 배열은 대부분 'g[행][열]'의 형식으로 사용한다. 2차원 배열에서 '배열이름.length'는 행의 크기를, '배열이름[0].length'는 인덱스가 0인 행에 대한 열의 크기를 나타낸다.
		for(int i =0; i<c.length;i++) {//
			System.arraycopy(c[i],0,d[i],0,d[i].length); //value assign  값 할당
			/*
			System.arraycopy는 1차원 배열을 값에 의한 대입으로 복사하여, 복사하려는 소스와 복사받으려는 데스티네이션 사이에 일대일로 값을 대입한다. 2차원 배열은 행에 대한 배열을 
			바꿔가면서 열에 대한 배열을 System.arraycopy로 복사한다. 따라서 2차원 배열 c를 2차원 배열 d에 복사한다. 2차원 이상의 배열은 참조에 의한 대입이 된다. 그러나 2차원 배열을
			1차원 배열 단위로 System.arraycopy를 하면 값에 의한 대입 복사가 가능하다.
			*/
		}
		c[0][0]=5;
		/*
		 * 값에 의한 대입을 확인하려면 c[0][0]에 -5를 대입한 후 배열 d를 출력했을 때 d[0][0]이 -5인지 확인한다.
		 * d[0][0]은 -5가 아니므로 값에 의한 대입이라는 것을 알 수 있다. [그림 75-3]의 배열 c는 배열 num에 대해 값에 의한 대입을 했을 때의 관계를 보여준다.
		 * c[0][0]의 값을 바꿔도 num[0][0]은 바뀌지 않는다.
		 */
		println(d);
		System.out.println();
		
		System.out.println("copy 2");
		int [][]e = new int[c.length][c[0].length];	//3*5배열
		for(int i =0; i<c.length;i++) {//
			System.arraycopy(c,0,e,0,e.length); //ref.assign
			/*
			 * 2차원 배열을 System.arraycopy하면 행에 대한 배열의 주소를 일대일로 넘겨주므로 참조에 의한 대입으로 복사된다.
			 */
		}
		c[0][0]=-4;
		/*
		 * 뮤터블(인스턴스가 생성된 후에 내용이 변할수 있는 클래스)을 확인하려면 c[0][0]에 -4를 대입한 뒤 배열 e를 출력 했을 때 e[0][0]이 -4인지 확인한다.
		 * e[0][0]은 -4 이므로 참조에 의한 대입으로 복사된 것을 알 수 있다. [그림 75-3]의 배열 b는 배열 num에 대해 참조에 의한 대입으로 복사했을 떄의 관계를 보여준다..
		 * b[0][0]의 값을 바꾸면 num[0][0]도 바뀐다.
		 */
		println(e);
		System.out.println();
		
		System.out.println("copy 3");
		int [][]f = new int[c.length][c[0].length];	//3*5배열
		f=e; //shallow copy
		/*가장 일반적인 참조에 의한 대입 복사이다.
		 * 참조에 의한 대입 복사를 확인하려면 'e[0][0]에 -400을 대입한 후 배열 f를 출력했을  f[0][0]이 -400인지 확인한다.
		 * f[0][0]은 -400이므로 참조에 의한 대입으로 복사되었다는 것을 알 수 있다. [그림75-3]의 배열 a는 배열 num에 대해 참조에 의한 대입으로 복사했을 때의 관계를 보여준다.
		 * a[0][0]의 값을 바꾸면 num[0][0]도 바뀐다.
		 * */
		e[0][0]=-400;
		println(f);
		System.out.println();
	}
	
	public static void println(int [][]p) {
		for(int i=0; i <p.length; i++) {
			for(int j = 0; j <p[i].length; j++) {
				System.out.print("["+p[i][j]+"]");
			}
			System.out.println();
		}
	}

	/*콘솔 확인
//2차원 배열 방법1
[1][2][0]
[0][0][0]
[0][0][0]
[0][0][5]

//2차원 배열 방법 2 (JigJagged도 가능)
[0][0][0][0]
[0][0][0][0][0]
[0][0][0][0][0][0]

//2차원 배열 방법 3
[1][2][3][4][5]
[2][3][4][5][6]
[6][7][8][9][0]

//2차원 배열 방법 4
[1][2][3][4][5]
[2][3][4][5][6]
[6][7][8][9][0]

copy 1
[1][2][3][4][5]
[2][3][4][5][6]
[6][7][8][9][0]

copy 2
[-4][2][3][4][5]
[2][3][4][5][6]
[6][7][8][9][0]

copy 3
[-400][2][3][4][5]
[2][3][4][5][6]
[6][7][8][9][0]
	 * */
	
}
